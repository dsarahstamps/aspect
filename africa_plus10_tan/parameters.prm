# Listing of Parameters
# ---------------------
# A list of names of additional shared libraries that should be loaded upon
# starting up the program. The names of these files can contain absolute or
# relative paths (relative to the directory in which you call ASPECT). In
# fact, file names that are do not contain any directory information (i.e.,
# only the name of a file such as <myplugin.so> will not be found if they are
# not located in one of the directories listed in the LD_LIBRARY_PATH
# environment variable. In order to load a library in the current directory,
# use <./myplugin.so> instead.
# 
# The typical use of this parameter is so that you can implement additional
# plugins in your own directories, rather than in the ASPECT source
# directories. You can then simply compile these plugins into a shared library
# without having to re-compile all of ASPECT. See the section of the manual
# discussing writing extensions for more information on how to compile
# additional files into a shared library.
set Additional shared libraries            = 

# In order to make the problem in the first time step easier to solve, we need
# a reasonable guess for the temperature and pressure. To obtain it, we use an
# adiabatic pressure and temperature field. This parameter describes what the
# `adiabatic' temperature would be at the surface of the domain (i.e. at depth
# zero). Note that this value need not coincide with the boundary condition
# posed at this point. Rather, the boundary condition may differ significantly
# from the adiabatic value, and then typically induce a thermal boundary
# layer.
# 
# For more information, see the section in the manual that discusses the
# general mathematical model.
set Adiabatic surface temperature          = 0

# In computations, the time step $k$ is chosen according to $k = c \min_K
# \frac {h_K} {\|u\|_{\infty,K} p_T}$ where $h_K$ is the diameter of cell $K$,
# and the denominator is the maximal magnitude of the velocity on cell $K$
# times the polynomial degree $p_T$ of the temperature discretization. The
# dimensionless constant $c$ is called the CFL number in this program. For
# time discretizations that have explicit components, $c$ must be less than a
# constant that depends on the details of the time discretization and that is
# no larger than one. On the other hand, for implicit discretizations such as
# the one chosen here, one can choose the time step as large as one wants (in
# particular, one can choose $c>1$) though a CFL number significantly larger
# than one will yield rather diffusive solutions. Units: None.
set CFL number                             = 1.0

# The relative tolerance up to which the linear system for the composition
# system gets solved. See 'linear solver tolerance' for more details.
set Composition solver tolerance           = 1e-12

# The number of space dimensions you want to run this program in. ASPECT can
# run in 2 and 3 space dimensions.
set Dimension                              = 3                 # default: 2

# The end time of the simulation. The default value is a number so that when
# converted from years to seconds it is approximately equal to the largest
# number representable in floating point arithmetic. For all practical
# purposes, this equals infinity. Units: Years if the 'Use years in output
# instead of seconds' parameter is set; seconds otherwise.
set End time                               = 0                 # default: 5.69e+300

# A relative tolerance up to which the linear Stokes systems in each time or
# nonlinear step should be solved. The absolute tolerance will then be the
# norm of the right hand side of the equation times this tolerance. A given
# tolerance value of 1 would mean that a zero solution vector is an acceptable
# solution since in that case the norm of the residual of the linear system
# equals the norm of the right hand side. A given tolerance of 0 would mean
# that the linear system has to be solved exactly, since this is the only way
# to obtain a zero residual.
# 
# In practice, you should choose the value of this parameter to be so that if
# you make it smaller the results of your simulation do not change any more
# (qualitatively) whereas if you make it larger, they do. For most cases, the
# default value should be sufficient. However, for cases where the static
# pressure is much larger than the dynamic one, it may be necessary to choose
# a smaller value.
set Linear solver tolerance                = 1e-4              # default: 1e-7

# The maximal number of nonlinear iterations to be performed.
set Max nonlinear iterations               = 6                 # default: 10

# Set a maximum time step size for the solver to use. Generally the time step
# based on the CFL number should be sufficient, but for complicated models or
# benchmarking it may be useful to limit the time step to some value. The
# default value is a value so that when converted from years into seconds it
# equals the largest number representable by a floating point number, implying
# an unlimited time step.Units: Years or seconds, depending on the ``Use years
# in output instead of seconds'' parameter.
set Maximum time step                      = 5.69e+300

# The kind of scheme used to resolve the nonlinearity in the system. 'IMPES'
# is the classical IMplicit Pressure Explicit Saturation scheme in which ones
# solves the temperatures and Stokes equations exactly once per time step, one
# after the other. The 'iterated IMPES' scheme iterates this decoupled
# approach by alternating the solution of the temperature and Stokes systems.
# The 'iterated Stokes' scheme solves the temperature equation once at the
# beginning of each time step and then iterates out the solution of the Stokes
# equation. The 'Stokes only' scheme only solves the Stokes system and ignores
# compositions and the temperature equation (careful, the material model must
# not depend on the temperature; mostly useful for Stokes benchmarks).
set Nonlinear solver scheme                = iterated Stokes   # default: IMPES

# A relative tolerance up to which the nonlinear solver will iterate. This
# parameter is only relevant if Nonlinear solver scheme is set to 'iterated
# Stokes' or 'iterated IMPES'.
set Nonlinear solver tolerance             = 1e-5

# As explained in the ASPECT paper (Kronbichler, Heister, and Bangerth, GJI
# 2012) we first try to solve the Stokes system in every time step using a
# GMRES iteration with a poor but cheap preconditioner. By default, we try
# whether we can converge the GMRES solver in 30 such iterations before
# deciding that we need a better preconditioner. This is sufficient for simple
# problems with constant viscosity and we never need the second phase with the
# more expensive preconditioner. On the other hand, for more complex problems,
# and in particular for problems with strongly varying viscosity, the 30 cheap
# iterations don't actually do very much good and one might skip this part
# right away. In that case, this parameter can be set to zero, i.e., we
# immediately start with the better but more expensive preconditioner.
set Number of cheap Stokes solver steps    = 0                 # default: 30

# The name of the directory into which all output files should be placed. This
# may be an absolute or a relative path.
set Output directory                       = africa_plus10_tan # default: output

# If and how to normalize the pressure after the solution step. This is
# necessary because depending on boundary conditions, in many cases the
# pressure is only determined by the model up to a constant. On the other
# hand, we often would like to have a well-determined pressure, for example
# for table lookups of material properties in models or for comparing
# solutions. If the given value is `surface', then normalization at the end of
# each time steps adds a constant value to the pressure in such a way that the
# average pressure at the surface of the domain is zero; the surface of the
# domain is determined by asking the geometry model whether a particular face
# of the geometry has a zero or small `depth'. If the value of this parameter
# is `volume' then the pressure is normalized so that the domain average is
# zero. If `no' is given, the no pressure normalization is performed.
set Pressure normalization                 = surface

# A flag indicating whether the computation should be resumed from a
# previously saved state (if true) or start from scratch (if false).
set Resume computation                     = false

# The start time of the simulation. Units: Years if the 'Use years in output
# instead of seconds' parameter is set; seconds otherwise.
set Start time                             = 0

# The mathematical equations that describe thermal convection only determine
# the pressure up to an arbitrary constant. On the other hand, for comparison
# and for looking up material parameters it is important that the pressure be
# normalized somehow. We do this by enforcing a particular average pressure
# value at the surface of the domain, where the geometry model determines
# where the surface is. This parameter describes what this average surface
# pressure value is supposed to be. By default, it is set to zero, but one may
# want to choose a different value for example for simulating only the volume
# of the mantle below the lithosphere, in which case the surface pressure
# should be the lithostatic pressure at the bottom of the lithosphere.
# 
# For more information, see the section in the manual that discusses the
# general mathematical model.
set Surface pressure                       = 0

# The relative tolerance up to which the linear system for the temperature
# system gets solved. See 'linear solver tolerance' for more details.
set Temperature solver tolerance           = 1e-7              # default: 1e-12

# How frequently in timesteps to output timing information. This is generally
# adjusted only for debugging and timing purposes.
set Timing output frequency                = 100

# Mantle convection simulations are often focused on convection dominated
# systems. However, these codes can also be used to investigate systems where
# heat conduction plays a dominant role. This parameter indicates whether the
# simulator should also use heat conduction in determining the length of each
# time step.
set Use conduction timestep                = false

# When computing results for mantle convection simulations, it is often
# difficult to judge the order of magnitude of results when they are stated in
# MKS units involving seconds. Rather, some kinds of results such as
# velocities are often stated in terms of meters per year (or, sometimes,
# centimeters per year). On the other hand, for non-dimensional computations,
# one wants results in their natural unit system as used inside the code. If
# this flag is set to 'true' conversion to years happens; if it is 'false', no
# such conversion happens.
set Use years in output instead of seconds = true


subsection Boundary composition model
  # Select one of the following models:
  # 
  # `box': A model in which the composition is chosen constant on all the
  # sides of a box.
  # 
  # `initial composition': A model in which the composition at the boundaryis
  # chosen to be the same as given in the initialconditions.
  # 
  # Because this class simply takes what the initial composition had
  # described, this class can not know certain pieces of information such as
  # the minimal and maximal composition on the boundary. For operations that
  # require this, for example in postprocessing, this boundary composition
  # model must therefore be told what the minimal and maximal values on the
  # boundary are. This is done using parameters set in section ``Boundary
  # composition model/Initial composition''.
  # 
  # `spherical constant': A model in which the composition is chosen constant
  # on the inner and outer boundaries of a spherical shell. Parameters are
  # read from subsection 'Sherical constant'.
  set Model name = 


  subsection Box
    # A comma separated list of composition boundary values at the back
    # boundary (at maximal y-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Back composition   = 

    # A comma separated list of composition boundary values at the bottom
    # boundary (at minimal y-value in 2d, or minimal z-value in 3d). This list
    # must have as many entries as there are compositional fields. Units:
    # none.
    set Bottom composition = 

    # A comma separated list of composition boundary values at the front
    # boundary (at momimal y-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Front composition  = 

    # A comma separated list of composition boundary values at the left
    # boundary (at minimal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Left composition   = 

    # A comma separated list of composition boundary values at the right
    # boundary (at maximal x-value). This list must have as many entries as
    # there are compositional fields. Units: none.
    set Right composition  = 

    # A comma separated list of composition boundary values at the top
    # boundary (at maximal y-value in 2d, or maximal z-value in 3d). This list
    # must have as many entries as there are compositional fields. Units:
    # none.
    set Top composition    = 
  end

  subsection Initial composition
    # Maximal composition. Units: none.
    set Maximal composition = 1

    # Minimal composition. Units: none.
    set Minimal composition = 0
  end

  subsection Spherical constant
    # Composition at the inner boundary (core mantle boundary). Units: K.
    set Inner composition = 1

    # Composition at the outer boundary (lithosphere water/air). Units: K.
    set Outer composition = 0
  end

end


subsection Boundary temperature model
  # Select one of the following models:
  # 
  # `box': A model in which the temperature is chosen constant on all the
  # sides of a box.
  # 
  # `constant': A model in which the temperature is chosen constant on a given
  # boundary indicator.  Parameters are read from the subsection 'Constant'.
  # 
  # `initial temperature': A model in which the temperature at the boundaryis
  # chosen to be the same as given in the initialconditions.
  # 
  # Because this class simply takes what the initial temperature had
  # described, this class can not know certain pieces of information such as
  # the minimal and maximal temperature on the boundary. For operations that
  # require this, for example in postprocessing, this boundary temperature
  # model must therefore be told what the minimal and maximal values on the
  # boundary are. This is done using parameters set in section ``Boundary
  # temperature model/Initial temperature''.
  # 
  # `spherical constant': A model in which the temperature is chosen constant
  # on the inner and outer boundaries of a spherical shell. Parameters are
  # read from subsection 'Spherical constant'.
  # 
  # `Tan Gurnis': A model for the Tan/Gurnis benchmark.
  set Model name = box # default: 


  subsection Box
    # Temperature at the back boundary (at maximal y-value). Units: K.
    set Back temperature   = 0

    # Temperature at the bottom boundary (at minimal z-value). Units: K.
    set Bottom temperature = 0

    # Temperature at the front boundary (at minimal y-value). Units: K.
    set Front temperature  = 0

    # Temperature at the left boundary (at minimal x-value). Units: K.
    set Left temperature   = 1

    # Temperature at the right boundary (at maximal x-value). Units: K.
    set Right temperature  = 0

    # Temperature at the top boundary (at maximal x-value). Units: K.
    set Top temperature    = 0
  end

  subsection Constant
    # A comma separated list of mappings between boundary indicators and the
    # temperature associated with the boundary indicators. The format for this
    # list is ``indicator1 : value1, indicator2 : value2, ...'', where each
    # indicator is a valid boundary indicator and each value is the
    # temperature of that boundary.
    set Boundary indicator to temperature mappings = 
  end

  subsection Initial temperature
    # Maximal temperature. Units: K.
    set Maximal temperature = 3773

    # Minimal temperature. Units: K.
    set Minimal temperature = 0
  end

  subsection Spherical constant
    # Temperature at the inner boundary (core mantle boundary). Units: K.
    set Inner temperature = 4273 # default: 6000

    # Temperature at the outer boundary (lithosphere water/air). Units: K.
    set Outer temperature = 973  # default: 0
  end

end


subsection Boundary velocity model
  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the fparser
    # library.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0; 0; 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,z,t
  end

  subsection GPlates model
    # The name of a directory that contains the model data. This path may
    # either be absolute (if starting with a '/') or relative to the current
    # directory. The path may also include the special text
    # '$ASPECT_SOURCE_DIR' which will be interpreted as the path in which the
    # ASPECT source files were located when ASPECT was compiled. This
    # interpretation allows, for example, to reference files located in the
    # 'data/' subdirectory of ASPECT.
    set Data directory           = $ASPECT_SOURCE_DIR/data/velocity-boundary-conditions/gplates/

    # Determines the width of the velocity interpolation zone around the
    # current point. Currently equals the arc distance between evaluation
    # point and velocity data point that is still included in the
    # interpolation. The weighting of the points currently only accounts for
    # the surface area a single data point is covering ('moving window'
    # interpolation without distance weighting).
    set Interpolation width      = 0

    # Point that determines the plane in which a 2D model lies in. Has to be
    # in the format 'a,b' where a and b are theta (polar angle)  and phi in
    # radians.
    set Point one                = 1.570796,0.0

    # Point that determines the plane in which a 2D model lies in. Has to be
    # in the format 'a,b' where a and b are theta (polar angle)  and phi in
    # radians.
    set Point two                = 1.570796,1.570796

    # Time step between following velocity files. Depending on the setting of
    # the global 'Use years in output instead of seconds' flag in the input
    # file, this number is either interpreted as seconds or as years. The
    # default is one million, i.e., either one million seconds or one million
    # years.
    set Time step                = 1e6

    # The file name of the material data. Provide file in format: (Velocity
    # file name).%d.gpml where %d is any sprintf integer qualifier, specifying
    # the format of the current file number.
    set Velocity file name       = phi.%d

    # Time at which the velocity file with number 0 shall be loaded. Previous
    # to this time, a no-slip boundary condition is assumed. Depending on the
    # setting of the global 'Use years in output instead of seconds' flag in
    # the input file, this number is either interpreted as seconds or as
    # years.
    set Velocity file start time = 0.0
  end

end


subsection Checkpointing
  # The number of timesteps between performing checkpoints. If 0 and time
  # between checkpoint is not specified, checkpointing will not be performed.
  # Units: None.
  set Steps between checkpoint = 0

  # The wall time between performing checkpoints. If 0, will use the
  # checkpoint step frequency instead. Units: Seconds.
  set Time between checkpoint  = 0
end


subsection Compositional fields
  # A list of integers smaller than or equal to the number of compositional
  # fields. All compositional fields in this list will be normalized before
  # the first timestep. The normalization is implemented in the following way:
  # First, the sum of the fields to be normalized is calculated at every point
  # and the global maximum is determined. Second, the compositional fields to
  # be normalized are divided by this maximum.
  set List of normalized fields = 

  # The number of fields that will be advected along with the flow field,
  # excluding velocity, pressure and temperature.
  set Number of fields          = 0
end


subsection Compositional initial conditions
  # Select one of the following models:
  # 
  # `function': Composition is given in terms of an explicit formula
  set Model name = function


  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the fparser
    # library.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,z,t
  end

end


subsection Discretization
  # The polynomial degree to use for the composition variable(s). Units:
  # None.
  set Composition polynomial degree           = 2

  # The polynomial degree to use for the velocity variables in the Stokes
  # system. The polynomial degree for the pressure variable will then be one
  # less in order to make the velocity/pressure pair conform with the usual
  # LBB (Babuska-Brezzi) condition. In other words, we are using a Taylor-Hood
  # element for the Stoeks equations and this parameter indicates the
  # polynomial degree of it. Units: None.
  set Stokes velocity polynomial degree       = 2

  # The polynomial degree to use for the temperature variable. Units: None.
  set Temperature polynomial degree           = 2

  # Whether to use a Stokes discretization that is locally conservative at the
  # expense of a larger number of degrees of freedom (true), or to go with a
  # cheaper discretization that does not locally conserve mass, although it is
  # globally conservative (false).
  # 
  # When using a locally conservative discretization, the finite element space
  # for the pressure is discontinuous between cells and is the polynomial
  # space $P_ {-q}$ of polynomials of degree $q$ in each variable separately.
  # Here, $q$ is one less than the value given in the parameter ``Stokes
  # velocity polynomial degree''. As a consequence of choosing this element,
  # it can be shown if the medium is considered incompressible that the
  # computed discrete velocity field $\mathbf u_h$ satisfies the property
  # $\int_ {\partial K} \mathbf u_h \cdot \mathbf n = 0$ for every cell $K$,
  # i.e., for each cell inflow and outflow exactly balance each other as one
  # would expect for an incompressible medium. In other words, the velocity
  # field is locally conservative.
  # 
  # On the other hand, if this parameter is set to ``false'', then the finite
  # element space is chosen as $Q_q$. This choice does not yield the local
  # conservation property but has the advantage of requiring fewer degrees of
  # freedom. Furthermore, the error is generally smaller with this choice.
  # 
  # For an in-depth discussion of these issues and a quantitative evaluation
  # of the different choices, see \cite {KHB12} .
  set Use locally conservative discretization = false


  subsection Stabilization parameters
    # The exponent $\alpha$ in the entropy viscosity stabilization. Valid
    # options are 1 or 2. The recommended setting is 2. (This parameter does
    # not correspond to any variable in the 2012 GJI paper by Kronbichler,
    # Heister and Bangerth that describes ASPECT. Rather, the paper always
    # uses 2 as the exponent in the definition of the entropy, following eq.
    # (15).).Units: None.
    set alpha = 2

    # The $\beta$ factor in the artificial viscosity stabilization. An
    # appropriate value for 2d is 0.078 and 0.117 for 3d. (For historical
    # reasons, the name used here is different from the one used in the 2012
    # GJI paper by Kronbichler, Heister and Bangerth that describes ASPECT.
    # This parameter corresponds to the factor $\alpha_\text {max}$ in the
    # formulas following equation (15) of the paper. After further
    # experiments, we have also chosen to use a different value than described
    # there: It can be chosen as stated there for uniformly refined meshes,
    # but it needs to be chosen larger if the mesh has cells that are not
    # squares or cubes.) Units: None.
    set beta  = 0.078

    # The $c_R$ factor in the entropy viscosity stabilization. (For historical
    # reasons, the name used here is different from the one used in the 2012
    # GJI paper by Kronbichler, Heister and Bangerth that describes ASPECT.
    # This parameter corresponds to the factor $\alpha_E$ in the formulas
    # following equation (15) of the paper. After further experiments, we have
    # also chosen to use a different value than described there.) Units:
    # None.
    set cR    = 0.33
  end

end


subsection Geometry model
  # Select one of the following models:
  # 
  # `africa': A 3D geometry that accounts to Earth's ellipticity assuming the
  # WGS84 ellipsoid definition. The domain stretches from 10 degrees south to
  # 5 degrees north, and from 26 degree east to 35 degrees east, encompassing
  # the central part of the East African Rift.Faces of model are defined as 0,
  # west; 1,east; 2, south; 3, north; 4, bottom; 5, top.
  # 
  # `box': A box geometry parallel to the coordinate directions. The extent of
  # the box in each coordinate direction is set in the parameter file. The box
  # geometry labels its 2*dim sides as follows: in 2d, boundary indicators 0
  # through 3 denote the left, right, bottom and top boundaries; in 3d,
  # boundary indicators 0 through 5 indicate left, right, front, back, bottom
  # and top boundaries. See also the documentation of the deal.II class
  # ``GeometryInfo''.
  # 
  # `sphere': Geometry model for sphere with a user specified radius.
  # 
  # `spherical shell': A geometry representing a spherical shell or a pice of
  # it. Inner and outer radii are read from the parameter file in subsection
  # 'Spherical shell'.
  # 
  # The model assigns boundary indicators as follows: In 2d, inner and outer
  # boundaries get boundary indicators zero and one, and if the opening angle
  # set in the input file is less than 360, then left and right boundaries are
  # assigned indicators two and three. In 3d, inner and outer indicators are
  # treated as in 2d. If the opening angle is chosen as 90 degrees, i.e., the
  # domain is the intersection of a spherical shell and the first octant, then
  # indicator 2 is at the face $x=0$, 3 at $y=0$, and 4 at $z=0$.
  set Model name = africa # default: 


  subsection Africa
    # Surface coordinates and topography. Units: degrees and meters.
    set Topography     = input_files/topography_plus10deg_uniform100.txt # default: topography.txt

    # Bottom depth of model region.
    set bottom depth   = 500000.0                                        # default: 50000.0

    # Eastern longitude of model region
    set east longitude = 38.0                                            # default: 26.0

    # Northern latitude of model region.
    set north latitude = 6.0                                             # default: 5.0

    # Southern latitude of model region.
    set south latitude = -10.0

    # Western longitude of model region.
    set west longitude = 24.0                                            # default: 35.0
  end

  subsection Box
    # Extent of the box in x-direction. Units: m.
    set X extent      = 1

    # Whether the box should be periodic in X direction
    set X periodic    = false

    # Number of cells in X direction.
    set X repetitions = 1

    # Extent of the box in y-direction. Units: m.
    set Y extent      = 1

    # Whether the box should be periodic in Y direction
    set Y periodic    = false

    # Number of cells in Y direction.
    set Y repetitions = 1

    # Extent of the box in z-direction. This value is ignored if the
    # simulation is in 2d Units: m.
    set Z extent      = 1

    # Whether the box should be periodic in Z direction
    set Z periodic    = false

    # Number of cells in Z direction.
    set Z repetitions = 1
  end

  subsection Sphere
    # Radius of the sphere. Units: m.
    set Radius = 6371000
  end

  subsection Spherical shell
    # Inner radius of the spherical shell. Units: m.
    set Inner radius  = 3481000

    # Opening angle in degrees of the section of the shell that we want to
    # build. Units: degrees.
    set Opening angle = 360

    # Outer radius of the spherical shell. Units: m.
    set Outer radius  = 6336000
  end

end


subsection Gravity model
  # Select one of the following models:
  # 
  # `radial constant': A gravity model in which the gravity direction is
  # radially inward and at constant magnitude. The magnitude is read from the
  # parameter file in subsection 'Radial constant'.
  # 
  # `radial earth-like': A gravity model in which the gravity direction is
  # radially inward and with a magnitude that matches that of the earth at the
  # core-mantle boundary as well as at the surface and in between is
  # physically correct under the assumption of a constant density.
  # 
  # `radial linear': A gravity model which is radially inward, where the
  # magnitudedecreases linearly with depth down to zero at the maximal depth
  # the geometry returns, as you would get with a constantdensity spherical
  # domain. (Note that this would be for a full sphere, not a spherical
  # shell.) The magnitude of gravity at the surface is read from the input
  # file in a section ``Gravity model/Radial linear''.
  # 
  # `vertical': A gravity model in which the gravity direction is vertically
  # downward and at a constant magnitude by default equal to one.
  set Model name = radial earth-like # default: 


  subsection Radial constant
    # Magnitude of the gravity vector in $m/s^2$. The direction is always
    # radially inward towards the center of the earth.
    set Magnitude = 9.81
  end

  subsection Radial linear
    # Magnitude of the radial gravity vector at the surface of the domain.
    # Units: $m/s^2$
    set Magnitude at surface = 9.8
  end

  subsection Vertical
    # Value of the gravity vector in $m/s^2$ directed along negative y (2D) or
    # z (3D) axis.
    set Magnitude = 1
  end

end


subsection Initial conditions
  # Select one of the following models:
  # 
  # `model regions': In subsection lithosphere isotherm we define the extent
  # of the conductive heat equation is assumed to be 1400 C (1673.15 K) as
  # previously used by Bird et al., 2008 and Stamps et al. (in prep). This
  # assumption is consistent with the Schubert 2001 definition of the
  # mechanical lithosphere.
  # 
  # `adiabatic': Temperature is prescribed as an adiabatic profile with upper
  # and lower thermal boundary layers, whose ages are given as input
  # parameters.
  # 
  # `perturbed box': An initial temperature field in which the temperature is
  # perturbed slightly from an otherwise constant value equal to one. The
  # perturbation is chosen in such a way that the initial temperature is
  # constant to one along the entire boundary.
  # 
  # `polar box': An initial temperature field in which the temperature is
  # perturbed slightly from an otherwise constant value equal to one. The
  # perturbation is such that there are two poles on opposing corners of the
  # box.
  # 
  # `inclusion shape perturbation': An initial temperature field in which
  # there is an inclusion in a constant-temperature box field. The size,
  # shape, gradient, position, and temperature of the inclusion are defined by
  # parameters.
  # 
  # `mandelbox': Fractal-shaped temperature field.
  # 
  # `function': Temperature is given in terms of an explicit formula
  # 
  # `harmonic perturbation': An initial temperature field in which the
  # temperature is perturbed following a harmonic function (spherical harmonic
  # or sine depending on geometry and dimension) in lateral and radial
  # direction from an otherwise constant temperature (incompressible model) or
  # adiabatic reference profile (compressible model).
  # 
  # `spherical hexagonal perturbation': An initial temperature field in which
  # the temperature is perturbed following a six-fold pattern in angular
  # direction from an otherwise spherically symmetric state.
  # 
  # `spherical gaussian perturbation': An initial temperature field in which
  # the temperature is perturbed by a single Gaussian added to an otherwise
  # spherically symmetric state. Additional parameters are read from the
  # parameter file in subsection 'Spherical gaussian perturbation'.
  set Model name = model regions # default: 


  subsection Adiabatic
    # The age of the lower thermal boundary layer, used for the calculation of
    # the half-space cooling model temperature. Units: years if the 'Use years
    # in output instead of seconds' parameter is set; seconds otherwise.
    set Age bottom boundary layer = 0e0

    # The age of the upper thermal boundary layer, used for the calculation of
    # the half-space cooling model temperature. Units: years if the 'Use years
    # in output instead of seconds' parameter is set; seconds otherwise.
    set Age top boundary layer    = 0e0

    # The amplitude (in K) of the initial spherical temperature perturbation
    # at the bottom of the model domain. This perturbation will be added to
    # the adiabatic temperature profile, but not to the bottom thermal
    # boundary layer. Instead, the maximum of the perturbation and the bottom
    # boundary layer temperature will be used.
    set Amplitude                 = 0e0

    # Where the initial temperature perturbation should be placed. If 'center'
    # is given, then the perturbation will be centered along a 'midpoint' of
    # some sort of the bottom boundary. For example, in the case of a box
    # geometry, this is the center of the bottom face; in the case of a
    # spherical shell geometry, it is along the inner surface halfway between
    # the bounding radial lines.
    set Position                  = center

    # The Radius (in m) of the initial spherical temperature perturbation at
    # the bottom of the model domain.
    set Radius                    = 0e0

    # If this value is larger than 0, the initial temperature profile will not
    # be adiabatic, but subadiabatic. This value gives the maximal deviation
    # from adiabaticity. Set to 0 for an adiabatic temperature profile. Units:
    # K.
    # 
    # The function object in the Function subsection represents the
    # compositional fields that will be used as a reference profile for
    # calculating the thermal diffusivity. The function depends only on
    # depth.
    set Subadiabaticity           = 0e0


    subsection Function
      # Sometimes it is convenient to use symbolic constants in the expression
      # that describes the function, rather than having to use its numeric
      # value everywhere the constant appears. These values can be defined
      # using this parameter, in the form `var1=value1, var2=value2, ...'.
      # 
      # A typical example would be to set this runtime parameter to
      # `pi=3.1415926536' and then use `pi' in the expression of the actual
      # formula. (That said, for convenience this class actually defines both
      # `pi' and `Pi' by default, but you get the idea.)
      set Function constants  = 

      # The formula that denotes the function you want to evaluate for
      # particular values of the independent variables. This expression may
      # contain any of the usual operations such as addition or
      # multiplication, as well as all of the common functions such as `sin'
      # or `cos'. In addition, it may contain expressions like `if(x>0, 1,
      # -1)' where the expression evaluates to the second argument if the
      # first argument is true, and to the third argument otherwise. For a
      # full overview of possible expressions accepted see the documentation
      # of the fparser library.
      # 
      # If the function you are describing represents a vector-valued function
      # with multiple components, then separate the expressions for individual
      # components by a semicolon.
      set Function expression = 0

      # The name of the variables as they will be used in the function,
      # separated by commas. By default, the names of variables at which the
      # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z'
      # (in 3d) for spatial coordinates and `t' for time. You can then use
      # these variable names in your function expression and they will be
      # replaced by the values of these variables at which the function is
      # currently evaluated. However, you can also choose a different set of
      # names for the independent variables at which to evaluate your function
      # expression. For example, if you work in spherical coordinates, you may
      # wish to set this input parameter to `r,phi,theta,t' and then use these
      # variable names in your function expression.
      set Variable names      = x,t
    end

  end

  subsection Function
    # Sometimes it is convenient to use symbolic constants in the expression
    # that describes the function, rather than having to use its numeric value
    # everywhere the constant appears. These values can be defined using this
    # parameter, in the form `var1=value1, var2=value2, ...'.
    # 
    # A typical example would be to set this runtime parameter to
    # `pi=3.1415926536' and then use `pi' in the expression of the actual
    # formula. (That said, for convenience this class actually defines both
    # `pi' and `Pi' by default, but you get the idea.)
    set Function constants  = 

    # The formula that denotes the function you want to evaluate for
    # particular values of the independent variables. This expression may
    # contain any of the usual operations such as addition or multiplication,
    # as well as all of the common functions such as `sin' or `cos'. In
    # addition, it may contain expressions like `if(x>0, 1, -1)' where the
    # expression evaluates to the second argument if the first argument is
    # true, and to the third argument otherwise. For a full overview of
    # possible expressions accepted see the documentation of the fparser
    # library.
    # 
    # If the function you are describing represents a vector-valued function
    # with multiple components, then separate the expressions for individual
    # components by a semicolon.
    set Function expression = 0

    # The name of the variables as they will be used in the function,
    # separated by commas. By default, the names of variables at which the
    # function will be evaluated is `x' (in 1d), `x,y' (in 2d) or `x,y,z' (in
    # 3d) for spatial coordinates and `t' for time. You can then use these
    # variable names in your function expression and they will be replaced by
    # the values of these variables at which the function is currently
    # evaluated. However, you can also choose a different set of names for the
    # independent variables at which to evaluate your function expression. For
    # example, if you work in spherical coordinates, you may wish to set this
    # input parameter to `r,phi,theta,t' and then use these variable names in
    # your function expression.
    set Variable names      = x,y,z,t
  end

  subsection Harmonic perturbation
    # Doubled first lateral wave number of the harmonic perturbation. Equals
    # the spherical harmonic degree in 3D spherical shells. In all other cases
    # one equals half of a sine period over the model domain. This allows for
    # single up-/downswings. Negative numbers reverse the sign of the
    # perturbation but are not allowed for the spherical harmonic case.
    set Lateral wave number one = 3

    # Doubled second lateral wave number of the harmonic perturbation. Equals
    # the spherical harmonic order in 3D spherical shells. In all other cases
    # one equals half of a sine period over the model domain. This allows for
    # single up-/downswings. Negative numbers reverse the sign of the
    # perturbation.
    set Lateral wave number two = 2

    # The magnitude of the Harmonic perturbation.
    set Magnitude               = 1.0

    # The reference temperature that is perturbed by theharmonic function.
    # Only used in incompressible models.
    set Reference temperature   = 1600.0

    # Doubled radial wave number of the harmonic perturbation.  One equals
    # half of a sine period over the model domain.  This allows for single
    # up-/downswings. Negative numbers  reverse the sign of the perturbation.
    set Vertical wave number    = 1
  end

  subsection Inclusion shape perturbation
    # The background temperature for the temperature field.
    set Ambient temperature   = 1.0

    # The X coordinate for the center of the shape.
    set Center X              = 0.5

    # The Y coordinate for the center of the shape.
    set Center Y              = 0.5

    # The Z coordinate for the center of the shape. This is only necessary for
    # three-dimensional fields.
    set Center Z              = 0.5

    # The gradient of the inclusion to be generated.
    set Inclusion gradient    = constant

    # The shape of the inclusion to be generated.
    set Inclusion shape       = circle

    # The temperature of the inclusion shape. This is only the true
    # temperature in the case of the constant gradient. In all other cases, it
    # gives one endpoint of the temperature gradient for the shape.
    set Inclusion temperature = 0.0

    # The radius of the inclusion to be generated. For shapes with no radius
    # (e.g. square), this will be the width, and for shapes with no width,
    # this gives a general guideline for the size of the shape.
    set Shape radius          = 1.0
  end

  subsection Model regions
    # Surface coordinates and depths to the 1673.15 K isotherm. Units: degrees
    # and kilometers.
    set Isotherm filename = input_files/lithosphere_plus10deg_uniform100.txt # default: thickness.txt
  end

  subsection Spherical gaussian perturbation
    # The amplitude of the perturbation.
    set Amplitude                           = 0.01

    # The angle where the center of the perturbation is placed.
    set Angle                               = 0e0

    # The file from which the initial geotherm table is to be read. The format
    # of the file is defined by what is read in
    # source/initial\_conditions/spherical\_shell.cc.
    set Filename for initial geotherm table = initial-geotherm-table

    # The non-dimensional radial distance where the center of the perturbation
    # is placed.
    set Non-dimensional depth               = 0.7

    # The standard deviation of the Gaussian perturbation.
    set Sigma                               = 0.2

    # The sign of the perturbation.
    set Sign                                = 1
  end

end


subsection Material model
  # Select one of the following models:
  # 
  # `stamps': A material model that has constant values for all coefficients
  # but the density and viscosity. This model uses the formulation that
  # assumes an incompressible medium despite the fact that the density follows
  # the law $\rho(T)=\rho_0(1-\beta(T-T_{\text{ref}})$. The temperature
  # dependency of viscosity is  switched off by default and follows the
  # formula$\eta(T)=\eta_0*e^{\eta_T*\Delta T / T_{\text{ref}})}$.The value
  # for the components of this formula and additional parameters are read from
  # the parameter file in subsection 'Stamps model'.
  # 
  # `SolCx': A material model that corresponds to the 'SolCx' benchmark
  # defined in Duretz et al., G-Cubed, 2011.
  # 
  # `SolKz': A material model that corresponds to the 'SolKz' benchmark
  # defined in Duretz et al., G-Cubed, 2011.
  # 
  # `Inclusion': A material model that corresponds to the 'Inclusion'
  # benchmark defined in Duretz et al., G-Cubed, 2011.
  # 
  # `latent heat': A material model that includes phase transitions and the
  # possibility that latent heat is released or absorbed when material crosses
  # one of the phase transitions of up to two different materials
  # (compositional fields). This model implements a standard approximation of
  # the latent heat terms following Christensen \& Yuen, 1986. The change of
  # entropy is calculated as $Delta S = \gamma \frac{\Delta\rho}{\rho^2}$ with
  # the Clapeyron slope $\gamma$ and the density change $\Delta\rho$ of the
  # phase transition being input parameters. The model employs an analytic
  # phase function in the form $X=0.5 \left( 1 + \tanh \left( \frac{\Delta
  # p}{\Delta p_0} \right) \right)$ with $\Delta p = p - p_{transition} -
  # \gamma \left( T - T_{transition} \right)$ and $\Delta p_0$ being the
  # pressure difference over the width of the phase transition (specified as
  # input parameter).
  # 
  # `simple': A simple material model that has constant values for all
  # coefficients but the density and viscosity. This model uses the
  # formulation that assumes an incompressible medium despite the fact that
  # the density follows the law $\rho(T)=\rho_0(1-\beta(T-T_{\text{ref}})$.
  # The temperature dependency of viscosity is  switched off by default and
  # follows the formula $\eta(T)=\eta_0 e^{\eta_T \cdot \Delta T /
  # T_{\text{ref}})}$.The value for the components of this formula and
  # additional parameters are read from the parameter file in subsection
  # 'Simple model'.
  # 
  # `Steinberger': This material model looks up the viscosity from the tables
  # that correspond to the paper of Steinberger and Calderwood 2006 (``Models
  # of large-scale viscous flow in the Earth's mantle with constraints from
  # mineral physics and surface observations'', Geophys. J. Int., 167,
  # 1461-1481, \url{http://dx.doi.org/10.1111/j.1365-246X.2006.03131.x}) and
  # material data from a database generated by the thermodynamics code
  # \texttt{Perplex}, see \url{http://www.perplex.ethz.ch/}. The database
  # builds upon the thermodynamic database by Stixrude 2011 and assumes a
  # pyrolitic composition by Ringwood 1988.
  # 
  # `table': A material model that reads tables of pressure and temperature
  # dependent material coefficients from files. The default values for this
  # model's runtime parameters use a material description taken from the paper
  # \textit{Complex phase distribution and seismic velocity structure of the
  # transition zone: Convection model predictions for a magnesium-endmember
  # olivine-pyroxene mantle} by Michael H.G. Jacobs and Arie P. van den Berg,
  # Physics of the Earth and Planetary Interiors, Volume 186, Issues 1-2, May
  # 2011, Pages 36--48. See
  # \url{http://www.sciencedirect.com/science/article/pii/S0031920111000422}.
  # 
  # `Tan Gurnis': A simple compressible material model based on a benchmark
  # from the paper of Tan/Gurnis (2007). This does not use the temperature
  # equation, but has a hardcoded temperature.
  set Model name = stamps # default: 


  subsection Inclusion
    # Viscosity in the Inclusion.
    set Viscosity jump = 1e3
  end

  subsection Latent heat
    # A list of activation enthalpies for the temperature dependence of the
    # viscosity of each phase. List must have one more entry than Phase
    # transition depths. Units: $1/K$.
    set Activation enthalpies                          = 

    # A linear dependency of viscosity on composition. Dimensionless
    # prefactor.
    set Composition viscosity prefactor                = 1.0

    # The value of the compressibility $\kappa$. Units: $1/Pa$.
    set Compressibility                                = 5.124e-12

    # A list of phases, which correspond to the Phase transition density
    # jumps. The density jumps occur only in the phase that is given by this
    # phase value. 0 stands for the 1st compositional fields, 1 for the second
    # compositional field and -1 for none of them. List must have the same
    # number of entries as Phase transition depths. Units: $Pa/K$.
    set Corresponding phase for density jump           = 

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first one in such a way
    # that the density has an additional term of the kind $+\Delta \rho \;
    # c_1(\mathbf x)$. This parameter describes the value of $\Delta \rho$.
    # Units: $kg/m^3/\textrm{unit change in composition}$.
    set Density differential for compositional field 1 = 0

    # A list of Clapeyron slopes for each phase transition. A positive
    # Clapeyron slope indicates that the phase transition will occur in a
    # greater depth, if the temperature is higher than the one given in Phase
    # transition temperatures and in a smaller depth, if the temperature is
    # smaller than the one given in Phase transition temperatures. For
    # negative slopes the other way round. List must have the same number of
    # entries as Phase transition depths. Units: $Pa/K$.
    set Phase transition Clapeyron slopes              = 

    # A list of density jumps at each phase transition. A positive value means
    # that the density increases with depth. The corresponding entry in
    # Corresponding phase for density jump determines if the density jump
    # occurs in peridotite, eclogite or none of them.List must have the same
    # number of entries as Phase transition depths. Units: $kg/m^3$.
    set Phase transition density jumps                 = 

    # A list of depths where phase transitions occur. Values must
    # monotonically increase. Units: $m$.
    set Phase transition depths                        = 

    # A list of temperatures where phase transitions occur. Higher or lower
    # temperatures lead to phase transition ocurring in smaller or greater
    # depths than given in Phase transition depths, depending on the Clapeyron
    # slope given in Phase transition Clapeyron slopes. List must have the
    # same number of entries as Phase transition depths. Units: $K$.
    set Phase transition temperatures                  = 

    # A list of widths for each phase transition. The phase functions are
    # scaled with these values, leading to a jump betwen phases for a value of
    # zero and a gradual transition for larger values. List must have the same
    # number of entries as Phase transition depths. Units: $m$.
    set Phase transition widths                        = 

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density                              = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat                        = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature                          = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity                           = 2.38

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient                  = 4e-5

    # The temperature dependence of viscosity. Dimensionless exponent.
    set Thermal viscosity exponent                     = 0.0

    # The value of the constant viscosity. Units: $kg/m/s$.
    set Viscosity                                      = 5e24

    # A list of prefactors for the viscosity for each phase. The reference
    # viscosity will be multiplied by this factor to get the corresponding
    # viscosity for each phase. List must have one more entry than Phase
    # transition depths. Units: non-dimensional.
    set Viscosity prefactors                           = 
  end

  subsection Simple model
    # A linear dependency of viscosity on the first compositional field.
    # Dimensionless prefactor. With a value of 1.0 (the default) the viscosity
    # does not depend on the composition.
    set Composition viscosity prefactor                = 1.0

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first one in such a way
    # that the density has an additional term of the kind $+\Delta \rho \;
    # c_1(\mathbf x)$. This parameter describes the value of $\Delta \rho$.
    # Units: $kg/m^3/\textrm{unit change in composition}$.
    set Density differential for compositional field 1 = 0

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density                              = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat                        = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature                          = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity                           = 4.7

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient                  = 2e-5

    # The temperature dependence of viscosity. Dimensionless exponent.
    set Thermal viscosity exponent                     = 0.0

    # The value of the constant viscosity. Units: $kg/m/s$.
    set Viscosity                                      = 1e22 # default: 5e24
  end

  subsection SolCx
    # Density value upon which the variation of this testcase is overlaid.
    # Since this background density is constant it does not affect the flow
    # pattern but it adds to the total pressure since it produces a nonzero
    # adiabatic pressure if set to a nonzero value.
    set Background density = 0

    # Viscosity in the right half of the domain.
    set Viscosity jump     = 1e6
  end

  subsection Stamps model
    # A linear dependency of viscosity on the first compositional field.
    # Dimensionless prefactor. With a value of 1.0 (the default) the viscosity
    # does not depend on the composition.
    set Composition viscosity prefactor                = 1.0

    # Surface coordinates and depths to the Mohovoric discontinuity. Units:
    # degrees and kilometers.
    set Crustal thickness filename                     = input_files/crust_plus10deg_uniform10.txt # default: crustal_thickness.txt

    # If compositional fields are used, then one would frequently want to make
    # the density depend on these fields. In this simple material model, we
    # make the following assumptions: if no compositional fields are used in
    # the current simulation, then the density is simply the usual one with
    # its linear dependence on the temperature. If there are compositional
    # fields, then the density only depends on the first one in such a way
    # that the density has an additional term of the kind $+\Delta \rho \;
    # c_1(\mathbf x)$. This parameter describes the value of $\Delta \rho$.
    # Units: $kg/m^3/\textrm{unit change in composition}$.
    set Density differential for compositional field 1 = 0

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density                              = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat                        = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature                          = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity                           = 4.7

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient                  = 2e-5

    # The temperature dependence of viscosity. Dimensionless exponent.
    set Thermal viscosity exponent                     = 0.0

    # The value of the constant viscosity. Units: $kg/m/s$.
    set Viscosity                                      = 5e24
  end

  subsection Steinberger model
    # whether to use bilinear interpolation to compute material properties
    # (slower but more accurate).
    set Bilinear interpolation      = true

    # The path to the model data.
    set Data directory              = data/material-model/steinberger/

    # whether to include latent heat effects in thecalculation of thermal
    # expansivity and specific heat.Following the approach of Nakagawa et al.
    # 2009.
    set Latent heat                 = false

    # The file name of the lateral viscosity data.
    set Lateral viscosity file name = temp-viscosity-prefactor.txt

    # The file names of the material data. List with as many components as
    # activecompositional fields (material data is assumed tobe in order with
    # the ordering of the fields).
    set Material file names         = pyr-ringwood88.txt

    # The file name of the radial viscosity data.
    set Radial viscosity file name  = radial-visc.txt
  end

  subsection Table model
    # The Composition of the model.
    set Composition                   = standard

    # whether the model is compressible.
    set Compressible                  = true

    # whether to compute phases.
    set ComputePhases                 = false

    # The value of the gravity constant.Units: $m/s^2$.
    set Gravity                       = 30

    # The path to the model data.
    set Path to model data            = data/material-model/table/

    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density             = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat       = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature         = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity          = 4.7

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient = 2e-5


    subsection Viscosity
      # The value of the constant viscosity. Units: $kg/m/s$.
      set Reference Viscosity             = 5e24

      # Viscosity Model
      set Viscosity Model                 = Exponential

      # The Viscosity increase (jump) in the lower mantle.
      set Viscosity increase lower mantle = 1e0


      subsection Composite
        # activation energy for diffusion creep
        set Activation energy diffusion   = 335e3

        # activation energy for dislocation creep
        set Activation energy dislocation = 540e3

        # activation volume for diffusion creep
        set Activation volume diffusion   = 4.0e-6

        # activation volume for dislocation creep
        set Activation volume dislocation = 14.0e-6

        # prefactor for diffusion creep
        # (1e0/prefactor)*exp((activation\_energy+activation\_volume*pressure)/(R*temperature))
        set Prefactor diffusion           = 1.92e-11

        # prefactor for dislocation creep
        # (1e0/prefactor)*exp((activation\_energy+activation\_volume*pressure)/(R*temperature))
        set Prefactor dislocation         = 2.42e-10

        # stress exponent for dislocation creep
        set Stress exponent               = 3.5
      end

      subsection Diffusion
        # activation energy for diffusion creep
        set Activation energy diffusion = 335e3

        # activation volume for diffusion creep
        set Activation volume diffusion = 4.0e-6

        # prefactor for diffusion creep
        # (1e0/prefactor)*exp((activation\_energy+activation\_volume*pressure)/(R*temperature))
        set Prefactor diffusion         = 1.92e-11
      end

      subsection Dislocation
        # activation energy for dislocation creep
        set Activation energy dislocation = 335e3

        # activation volume for dislocation creep
        set Activation volume dislocation = 4.0e-6

        # prefactor for dislocation creep
        # (1e0/prefactor)*exp((activation\_energy+activation\_volume*pressure)/(R*temperature))
        set Prefactor dislocation         = 1.92e-11

        # stress exponent for dislocation creep
        set Stress exponent               = 3.5
      end

      subsection Exponential
        # multiplication factor or Pressure exponent
        set Exponential P = 1

        # multiplication factor or Temperature exponent
        set Exponential T = 1
      end

    end

  end

  subsection Tan Gurnis model
    set Di                            = 0.5
    # Reference density $\rho_0$. Units: $kg/m^3$.
    set Reference density             = 3300

    # The value of the specific heat $cp$. Units: $J/kg/K$.
    set Reference specific heat       = 1250

    # The reference temperature $T_0$. Units: $K$.
    set Reference temperature         = 293

    # The value of the thermal conductivity $k$. Units: $W/m/K$.
    set Thermal conductivity          = 4.7

    # The value of the thermal expansion coefficient $\beta$. Units: $1/K$.
    set Thermal expansion coefficient = 2e-5

    # The value of the constant viscosity. Units: $kg/m/s$.
    set Viscosity                     = 5e24
    set a                             = 0
    set gamma                         = 1
    set wavenumber                    = 1
  end

end


subsection Mesh refinement
  # A list of times so that if the end time of a time step is beyond this
  # time, an additional round of mesh refinement is triggered. This is mostly
  # useful to make sure we can get through the initial transient phase of a
  # simulation on a relatively coarse mesh, and then refine again when we are
  # in a time range that we are interested in and where we would like to use a
  # finer mesh. Units: Each element of the list has units years if the 'Use
  # years in output instead of seconds' parameter is set; seconds otherwise.
  set Additional refinement times              = 

  # The fraction of cells with the smallest error that should be flagged for
  # coarsening.
  set Coarsening fraction                      = 0.05

  # The number of adaptive refinement steps performed after initial global
  # refinement but while still within the first time step.
  set Initial adaptive refinement              = 0                      # default: 2

  # The number of global refinement steps performed on the initial coarse
  # mesh, before the problem is first solved there.
  set Initial global refinement                = 3                      # default: 2

  # The minimum refinement level each cell should have, and that can not be
  # exceeded by coarsening. Should be higher than the 'Initial global
  # refinement' parameter.
  set Minimum refinement level                 = 0

  # If multiple refinement criteria are specified in the ``Strategy''
  # parameter, then they need to be combined somehow to form the final
  # refinement indicators. This is done using the method described by the
  # ``Refinement criteria merge operation'' parameter which can either operate
  # on the raw refinement indicators returned by each strategy (i.e.,
  # dimensional quantities) or using normalized values where the indicators of
  # each strategy are first normalized to the interval $[0,1]$ (which also
  # makes them non-dimensional). This parameter determines whether this
  # normalization will happen.
  set Normalize individual refinement criteria = true

  # If multiple mesh refinement criteria are computed for each cell (by
  # passing a list of more than element to the \texttt{Strategy} parameter in
  # this section of the input file) then one will have to decide which one
  # should win when deciding which cell to refine. The operation that selects
  # from these competing criteria is the one that is selected here. The
  # options are:
  # 
  # \begin{itemize}
  # \item \texttt{plus}: Add the various error indicators together and refine
  # those cells on which the sum of indicators is largest.
  # \item \texttt{max}: Take the maximum of the various error indicators and
  # refine those cells on which the maximal indicators is largest.
  # \end{itemize}The refinement indicators computed by each strategy are
  # modified by the ``Normalize individual refinement criteria'' and
  # ``Refinement criteria scale factors'' parameters.
  set Refinement criteria merge operation      = max

  # A list of scaling factors by which every individual refinement criterion
  # will be multiplied by. If only a single refinement criterion is selected
  # (using the ``Strategy'' parameter, then this parameter has no particular
  # meaning. On the other hand, if multiple criteria are chosen, then these
  # factors are used to weigh the various indicators relative to each other.
  # 
  # If ``Normalize individual refinement criteria'' is set to true, then the
  # criteria will first be normalized to the interval $[0,1]$ and then
  # multiplied by the factors specified here. You will likely want to choose
  # the factors to be not too far from 1 in that case, say between 1 and 10,
  # to avoid essentially disabling those criteria with small weights. On the
  # other hand, if the criteria are not normalized to $[0,1]$ using the
  # parameter mentioned above, then the factors you specify here need to take
  # into account the relative numerical size of refinement indicators (which
  # in that case carry physical units).
  # 
  # You can experimentally play with these scaling factors by choosing to
  # output the refinement indicators into the graphical output of a run.
  # 
  # If the list of indicators given in this parameter is empty, then this
  # indicates that they should all be chosen equal to one. If the list is not
  # empty then it needs to have as many entries as there are indicators chosen
  # in the ``Strategy'' parameter.
  set Refinement criteria scaling factors      = 

  # The fraction of cells with the largest error that should be flagged for
  # refinement.
  set Refinement fraction                      = 0.3

  # Whether or not the postproccessors should be run at the end of each of ths
  # initial adaptive refinement cycles at the of the simulation start.
  set Run postprocessors on initial refinement = false

  # A comma separated list of mesh refinement criteria that will be run
  # whenever mesh refinement is required. The results of each of these
  # criteria will, i.e., the refinement indicators they produce for all the
  # cells of the mesh will then be normalized to a range between zero and one
  # and the results of different criteria will then be merged through the
  # operation selected in this section.
  # 
  # The following criteria are available:
  # 
  # `composition': A mesh refinement criterion that computes refinement
  # indicators from the compositional fields. If there is more than one
  # compositional field, then it simply takes the sum of the indicators
  # computed from each of the compositional field.
  # 
  # `density': A mesh refinement criterion that computes refinement indicators
  # from a field that describes the spatial variability of the density,
  # $\rho$. Because this quantity may not be a continuous function ($\rho$ and
  # $C_p$ may be discontinuous functions along discontinuities in the medium,
  # for example due to phase changes), we approximate the gradient of this
  # quantity to refine the mesh. The error indicator defined here takes the
  # magnitude of the approximate gradient and scales it by $h_K^{1+d/2}$ where
  # $h_K$ is the diameter of each cell and $d$ is the dimension. This scaling
  # ensures that the error indicators converge to zero as $h_K\rightarrow 0$
  # even if the energy density is discontinuous, since the gradient of a
  # discontinuous function grows like $1/h_K$.
  # 
  # `nonadiabatic temperature': A mesh refinement criterion that computes
  # refinement indicators from the excess temperature(difference between
  # temperature and adiabatic temperature.
  # 
  # `temperature': A mesh refinement criterion that computes refinement
  # indicators from the temperature field.
  # 
  # `thermal energy density': A mesh refinement criterion that computes
  # refinement indicators from a field that describes the spatial variability
  # of the thermal energy density, $\rho C_p T$. Because this quantity may not
  # be a continuous function ($\rho$ and $C_p$ may be discontinuous functions
  # along discontinuities in the medium, for example due to phase changes), we
  # approximate the gradient of this quantity to refine the mesh. The error
  # indicator defined here takes the magnitude of the approximate gradient and
  # scales it by $h_K^{1.5}$ where $h_K$ is the diameter of each cell. This
  # scaling ensures that the error indicators converge to zero as
  # $h_K\rightarrow 0$ even if the energy density is discontinuous, since the
  # gradient of a discontinuous function grows like $1/h_K$.
  # 
  # `topography': A class that implements a mesh refinement criterion, which
  # always flags all cells in the uppermost layer for refinement. This is
  # useful to provide high accuracy for processes at or close to the surface.
  # 
  # To use this refinement criterion, you may want to combine it with other
  # refinement criteria, setting the 'Normalize individual refinement
  # criteria' flag and using the 'max' setting for 'Refinement criteria merge
  # operation'.
  # 
  # `velocity': A mesh refinement criterion that computes refinement
  # indicators from the velocity field.
  # 
  # `viscosity': A mesh refinement criterion that computes refinement
  # indicators from a field that describes the spatial variability of the
  # logarithm of the viscosity, $\log\eta$. (We choose the logarithm of the
  # viscosity because it can vary by orders of magnitude.)Because this
  # quantity may not be a continuous function ($\eta$ may be a discontinuous
  # function along discontinuities in the medium, for example due to phase
  # changes), we approximate the gradient of this quantity to refine the mesh.
  # The error indicator defined here takes the magnitude of the approximate
  # gradient and scales it by $h_K^{1+d/2}$ where $h_K$ is the diameter of
  # each cell and $d$ is the dimension. This scaling ensures that the error
  # indicators converge to zero as $h_K\rightarrow 0$ even if the energy
  # density is discontinuous, since the gradient of a discontinuous function
  # grows like $1/h_K$.
  set Strategy                                 = thermal energy density

  # The number of time steps after which the mesh is to be adapted again based
  # on computed error indicators. If 0 then the mesh will never be changed.
  set Time steps between mesh refinement       = 0                      # default: 10


  subsection Composition
    # A list of scaling factors by which every individual compositional field
    # will be multiplied by. If only a single compositional field exists, then
    # this parameter has no particular meaning. On the other hand, if multiple
    # criteria are chosen, then these factors are used to weigh the various
    # indicators relative to each other.
    # 
    # If the list of scaling factors given in this parameter is empty, then
    # this indicates that they should all be chosen equal to one. If the list
    # is not empty then it needs to have as many entries as there are
    # compositional fields.
    set Compositional field scaling factors = 
  end

end


subsection Model settings
  # A comma separated list of integers denoting those boundaries on which the
  # composition is fixed and described by the boundary composition object
  # selected in its own section of this input file. All boundary indicators
  # used by the geometry but not explicitly listed here will end up with
  # no-flux (insulating) boundary conditions.
  # 
  # This parameter only describes which boundaries have a fixed composition,
  # but not what composition should hold on these boundaries. The latter piece
  # of information needs to be implemented in a plugin in the
  # BoundaryComposition group, unless an existing implementation in this group
  # already provides what you want.
  set Fixed composition boundary indicators   = 

  # A comma separated list of integers denoting those boundaries on which the
  # temperature is fixed and described by the boundary temperature object
  # selected in its own section of this input file. All boundary indicators
  # used by the geometry but not explicitly listed here will end up with
  # no-flux (insulating) boundary conditions.
  # 
  # This parameter only describes which boundaries have a fixed temperature,
  # but not what temperature should hold on these boundaries. The latter piece
  # of information needs to be implemented in a plugin in the
  # BoundaryTemperature group, unless an existing implementation in this group
  # already provides what you want.
  set Fixed temperature boundary indicators   = 

  # Whether to include adiabatic heating into the model or not. From a
  # physical viewpoint, adiabatic heating should always be used but may be
  # undesirable when comparing results with known benchmarks that do not
  # include this term in the temperature equation.
  set Include adiabatic heating               = false

  # Whether to include the generation of latent heat at phase transitions into
  # the model or not. From a physical viewpoint, latent heat should always be
  # used but may be undesirable when comparing results with known benchmarks
  # that do not include this term in the temperature equation or when dealing
  # with a model without phase transitions.
  set Include latent heat                     = false

  # Whether to include shear heating into the model or not. From a physical
  # viewpoint, shear heating should always be used but may be undesirable when
  # comparing results with known benchmarks that do not include this term in
  # the temperature equation.
  set Include shear heating                   = false       # default: true

  # A comma separated list denoting those boundaries on which the velocity is
  # tangential but prescribed, i.e., where external forces act to prescribe a
  # particular velocity. This is often used to prescribe a velocity that
  # equals that of overlying plates.
  # 
  # The format of valid entries for this parameter is that of a map given as
  # ``key1 [selector]: value1, key2 [selector]: value2, key3: value3, ...''
  # where each key must be a valid boundary indicator (which is an integer)
  # and each value must be one of the currently implemented boundary velocity
  # models. selector is an optional string given as a subset of the letters
  # 'xyz' that allows you to apply the boundary conditions only to the
  # components listed. As an example, '1 y: function' applies the type
  # 'function' to the y component on boundary 1. Without a selector it will
  # effect all components of the velocity.
  # 
  # Note that the no-slip boundary condition is a special case of the current
  # one where the prescribed velocity happens to be zero. It can thus be
  # implemented by indicating that a particular boundary is part of the ones
  # selected using the current parameter and using ``zero velocity'' as the
  # boundary values. Alternatively, you can simply list the part of the
  # boundary on which the velocity is to be zero with the parameter ``Zero
  # velocity boundary indicator'' in the current parameter section.
  set Prescribed velocity boundary indicators = 

  # The rate of heating due to radioactive decay (or other bulk sources you
  # may want to describe). This parameter corresponds to the variable $H$ in
  # the temperature equation stated in the manual, and the heating term is
  # $ho H$. Units: W/kg.
  set Radiogenic heating rate                 = 0           # default: 0e0

  # A selection of operations to remove certain parts of the nullspace from
  # the velocity after solving. For some geometries and certain boundary
  # conditions the velocity field is not uniquely determined but contains free
  # translations and or rotations. Depending on what you specify here, these
  # non-determined modes will be removed from the velocity field at the end of
  # the Stokes solve step.
  # Note that while more than operation can be selected it only makes sense to
  # pick one rotational and one translational operation.
  set Remove nullspace                        = 

  # A comma separated list of integers denoting those boundaries on which the
  # velocity is tangential and unrestrained, i.e., free-slip where no external
  # forces act to prescribe a particular tangential velocity (although there
  # is a force that requires the flow to be tangential).
  set Tangential velocity boundary indicators = 0,1,2,3,4,5 # default: 

  # A comma separated list of integers denoting those boundaries on which the
  # velocity is zero.
  set Zero velocity boundary indicators       = 
end


subsection Postprocess
  # A comma separated list of postprocessor objects that should be run at the
  # end of each time step. Some of these postprocessors will declare their own
  # parameters which may, for example, include that they will actually do
  # something only every so many time steps or years. Alternatively, the text
  # 'all' indicates that all available postprocessors should be run after each
  # time step.
  # 
  # The following postprocessors are available:
  # 
  # `surface velocities': Output surface velocities at the centers of surface
  # faces.
  # 
  # `composition statistics': A postprocessor that computes some statistics
  # about the compositional fields, if present in this simulation. In
  # particular, it computes maximal and minimal values of each field, as well
  # as the total mass contained in this field as defined by the integral
  # $m_i(t) = \int_\Omega c_i(\mathbf x,t) \; dx$.
  # 
  # `depth average': A postprocessor that computes depth averaged quantities
  # and writes them into a file <depth_average.ext> in the output directory,
  # where the extension of the file is determined by the output format you
  # select. In addition to the output format, a number of other parameters
  # also influence this postprocessor, and they can be set in the section
  # \texttt{Postprocess/Depth average} in the input file.
  # 
  # `DuretzEtAl error': A postprocessor that compares the solution of the
  # benchmarks from the Duretz et al., G-Cubed, 2011, paper with the one
  # computed by ASPECT and reports the error. Specifically, it can compute the
  # errors for the SolCx, SolKz and inclusion benchmarks. The postprocessor
  # inquires which material model is currently being used and adjusts which
  # exact solution to use accordingly.
  # 
  # `dynamic topography': A postprocessor that computes a measure of dynamic
  # topography based on the stress at the surface. The data is writte into a
  # file named 'dynamic_topography.NNNNN' in the output directory, where NNNNN
  # is the number of the time step.
  # 
  # The exact approach works as follows: At the centers of all cells that sit
  # along the top surface, we evaluate the stress and evaluate the component
  # of it in the direction in which gravity acts. In other words, we compute
  # $\sigma_{rr}={\hat g}^T(2 \eta \varepsilon(\mathbf u))\hat g$ where $\hat
  # g = \mathbf g/\|\mathbf g\|$ is the direction of the gravity vector
  # $\mathbf g$. From this, the dynamic topography is computed using the
  # formula $h=\frac{\sigma_{rr}}{\|\mathbf g\| \rho}$ where $\rho$ is the
  # density at the cell center.
  # 
  # (As a side note, the postprocessor chooses the cell center instead of the
  # center of the cell face at the surface, where we really are interested in
  # the quantity, since this often gives better accuracy. The results should
  # in essence be the same, though.)
  # 
  # `heat flux statistics': A postprocessor that computes some statistics
  # about the (conductive) heat flux across boundaries. For each boundary
  # indicator (see your geometry description for which boundary indicators are
  # used), the heat flux is computed in outward direction, i.e., from the
  # domain to the outside, using the formula $\int_{\Gamma_i} k \nabla T \cdot
  # \mathbf n$ where $\Gamma_i$ is the part of the boundary with indicator
  # $i$, $k$ is the thermal conductivity as reported by the material model,
  # $T$ is the temperature, and $\mathbf n$ is the outward normal. Note that
  # the quantity so computed does not include any energy transported across
  # the boundary by material transport in cases where $\mathbf u \cdot \mathbf
  # n \neq 0$.
  # 
  # As stated, this postprocessor computes the \textit{outbound} heat flux. If
  # you are interested in the opposite direction, for example from the core
  # into the mantle when the domain describes the mantle, then you need to
  # multiply the result by -1.
  # 
  # `heat flux statistics for the table model': A postprocessor that computes
  # some statistics about the heat flux across boundaries.
  # 
  # `velocity statistics for the table model': A postprocessor that computes
  # some statistics about the velocity field.
  # 
  # `Tan Gurnis error': A postprocessor that compares the solution of the
  # benchmarks from the Tan/Gurnis (2007) paper with the one computed by
  # ASPECT by outputing data that is compared using a matlab script.
  # 
  # `temperature statistics': A postprocessor that computes some statistics
  # about the temperature field.
  # 
  # `tracers': Postprocessor that propagates passive tracer particles based on
  # the velocity field.
  # 
  # `velocity statistics': A postprocessor that computes some statistics about
  # the velocity field.
  # 
  # `visualization': A postprocessor that takes the solution and writes it
  # into files that can be read by a graphical visualization program.
  # Additional run time parameters are read from the parameter subsection
  # 'Visualization'.
  set List of postprocessors = visualization, surface velocities, depth average # default: all


  subsection Depth average
    # The number of zones in depth direction within which we are to compute
    # averages. By default, we subdivide the entire domain into 100 depth
    # zones and compute temperature and other averages within each of these
    # zones. However, if you have a very coarse mesh, it may not make much
    # sense to subdivide the domain into so many zones and you may wish to
    # choose less than this default. It may also make computations slightly
    # faster. On the other hand, if you have an extremely highly resolved
    # mesh, choosing more zones might also make sense.
    set Number of zones               = 100

    # The format in which the output shall be produced. The format in which
    # the output is generated also determiens the extension of the file into
    # which data is written.
    set Output format                 = gnuplot

    # The time interval between each generation of graphical output files. A
    # value of zero indicates that output should be generated in each time
    # step. Units: years if the 'Use years in output instead of seconds'
    # parameter is set; seconds otherwise.
    set Time between graphical output = 1e8
  end

  subsection Tracers
    # File format to output raw particle data in.
    set Data output format       = none

    # Integration scheme to move particles.
    set Integration scheme       = rk2

    # Total number of tracers to create (not per processor or per element).
    # The number is parsed as a floating point number (so that one can
    # specify, for example, '1e4' particles) but it is interpreted as an
    # integer, of course.
    set Number of tracers        = 1000

    # The time interval between each generation of output files. A value of
    # zero indicates that output should be generated every time step.
    # 
    # Units: years if the 'Use years in output instead of seconds' parameter
    # is set; seconds otherwise.
    set Time between data output = 1e8
  end

  subsection Visualization
    # A comma separated list of visualization objects that should be run
    # whenever writing graphical output. By default, the graphical output
    # files will always contain the primary variables velocity, pressure, and
    # temperature. However, one frequently wants to also visualize derived
    # quantities, such as the thermodynamic phase that corresponds to a given
    # temperature-pressure value, or the corresponding seismic wave speeds.
    # The visualization objects do exactly this: they compute such derived
    # quantities and place them into the output file. The current parameter is
    # the place where you decide which of these additional output variables
    # you want to have in your output file.
    # 
    # The following postprocessors are available:
    # 
    # `artificial viscosity': A visualization output object that generates
    # output showing the value of the artificial viscosity on each cell.
    # 
    # `density': A visualization output object that generates output for the
    # density.
    # 
    # `dynamic topography': A visualization output object that generates
    # output for the dynamic topography. The approach to determine the dynamic
    # topography requires us to compute the stress tensor and evaluate the
    # component of it in the direction in which gravity acts. In other words,
    # we compute $\sigma_{rr}={\hat g}^T(2 * \eta \varepsilon(\mathbf u))\hat
    # g$ where $\hat g = \mathbf g/\|\mathbf g\|$ is the direction of the
    # gravity vector $\mathbf g$. From this, the dynamic topography is
    # computed using the formula $h=\frac{\sigma_{rr}}{\|\mathbf g\| \rho}$
    # where $\rho$ is the density at the cell center.
    # 
    # Strictly speaking, the dynamic topography is of course a quantity that
    # is only of interest at the surface. However, we compute it everywhere to
    # make things fit into the framework within which we produce data for
    # visualization. You probably only want to visualize whatever data this
    # postprocessor generates at the surface of your domain and simply ignore
    # the rest of the data generated.
    # 
    # `error indicator': A visualization output object that generates output
    # showing the estimated error or other mesh refinement indicator as a
    # spatially variable function with one value per cell.
    # 
    # `friction heating': A visualization output object that generates output
    # for the amount of friction heating often referred to as $\tau:\epsilon$.
    # More concisely, in the incompressible case, the quantity that is output
    # is defined as $\eta \varepsilon(\mathbf u):\varepsilon(\mathbf u)$ where
    # $\eta$ is itself a function of temperature, pressure and strain rate. In
    # the compressible case, the quantity that's computed is $\eta
    # [\varepsilon(\mathbf u)-\tfrac 13(\textrm{tr}\;\varepsilon(\mathbf
    # u))\mathbf I]:[\varepsilon(\mathbf u)-\tfrac
    # 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I]$.
    # 
    # `melt fraction': A visualization output object that generates output for
    # the melt fraction at the temperature and pressure of the current point
    # (batch melting). Does not take into account latent heat.
    # 
    # `nonadiabatic pressure': A visualization output object that generates
    # output for the non-adiabatic component of the pressure.
    # 
    # `nonadiabatic temperature': A visualization output object that generates
    # output for the non-adiabatic component of the pressure.
    # 
    # `partition': A visualization output object that generates output for the
    # parallel partition that every cell of the mesh is associated with.
    # 
    # `Vs anomaly': A visualization output object that generates output
    # showing the anomaly in the seismic shear wave speed $V_s$ as a spatially
    # variable function with one value per cell. This anomaly is shown as a
    # percentage change relative to the average value of $V_s$ at the depth of
    # this cell.
    # 
    # `Vp anomaly': A visualization output object that generates output
    # showing the anomaly in the seismic compression wave speed $V_p$ as a
    # spatially variable function with one value per cell. This anomaly is
    # shown as a percentage change relative to the average value of $V_p$ at
    # the depth of this cell.
    # 
    # `seismic vp': A visualization output object that generates output for
    # the seismic P-wave speed.
    # 
    # `seismic vs': A visualization output object that generates output for
    # the seismic S-wave speed.
    # 
    # `specific heat': A visualization output object that generates output for
    # the specific heat $C_p$.
    # 
    # `strain rate': A visualization output object that generates output for
    # the norm of the strain rate, i.e., for the quantity
    # $\sqrt{\varepsilon(\mathbf u):\varepsilon(\mathbf u)}$ in the
    # incompressible case and $\sqrt{[\varepsilon(\mathbf u)-\tfrac
    # 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I]:[\varepsilon(\mathbf
    # u)-\tfrac 13(\textrm{tr}\;\varepsilon(\mathbf u))\mathbf I]}$ in the
    # compressible case.
    # 
    # `thermal expansivity': A visualization output object that generates
    # output for the thermal expansivity.
    # 
    # `thermodynamic phase': A visualization output object that generates
    # output for the integer number of the phase that is thermodynamically
    # stable at the temperature and pressure of the current point.
    # 
    # `viscosity': A visualization output object that generates output for the
    # viscosity.
    # 
    # `viscosity ratio': A visualization output object that generates output
    # for the ratio between dislocation viscosity and diffusion viscosity.
    set List of output variables      = viscosity, density, strain rate, dynamic topography # default: 

    # VTU file output supports grouping files from several CPUs into one file
    # using MPI I/O when writing on a parallel filesystem. Select 0 for no
    # grouping. This will disable parallel file output and instead write one
    # file per processor in a background thread. A value of 1 will generate
    # one big file containing the whole solution.
    set Number of grouped files       = 0

    # The file format to be used for graphical output.
    set Output format                 = vtu

    # The time interval between each generation of graphical output files. A
    # value of zero indicates that output should be generated in each time
    # step. Units: years if the 'Use years in output instead of seconds'
    # parameter is set; seconds otherwise.
    set Time between graphical output = 1.0                                                 # default: 1e8


    subsection Melt fraction
      # Constant parameter in the quadratic function that approximates the
      # solidus of peridotite. Units: $C$.
      set A1                = 1085.7

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the solidus of peridotite. Units: $C/Pa$.
      set A2                = 1.329e-7

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the solidus of peridotite. Units: $C/(Pa^2)$.
      set A3                = -5.1e-18

      # Constant parameter in the quadratic function that approximates the
      # lherzolite liquidus used for calculating the fraction of
      # peridotite-derived melt. Units: $C$.
      set B1                = 1475.0

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the  lherzolite liquidus used for calculating the
      # fraction of peridotite-derived melt. Units: $C/Pa$.
      set B2                = 8.0e-8

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the  lherzolite liquidus used for calculating the
      # fraction of peridotite-derived melt. Units: $C/(Pa^2)$.
      set B3                = -3.2e-18

      # Constant parameter in the quadratic function that approximates the
      # liquidus of peridotite. Units: $C$.
      set C1                = 1780.0

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the liquidus of peridotite. Units: $C/Pa$.
      set C2                = 4.50e-8

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the liquidus of peridotite. Units: $C/(Pa^2)$.
      set C3                = -2.0e-18

      # Constant parameter in the quadratic function that approximates the
      # solidus of pyroxenite. Units: $C$.
      set D1                = 976.0

      # Prefactor of the linear pressure term in the quadratic function that
      # approximates the solidus of pyroxenite. Units: $C/Pa$.
      set D2                = 1.23e-7

      # Prefactor of the quadratic pressure term in the quadratic function
      # that approximates the solidus of pyroxenite. Units: $C/(Pa^2)$.
      set D3                = -5.1e-18

      # Prefactor of the linear depletion term in the quadratic function that
      # approximates the melt fraction of pyroxenite. Units: $C/Pa$.
      set E1                = 633.8

      # Prefactor of the quadratic depletion term in the quadratic function
      # that approximates the melt fraction of pyroxenite. Units:
      # $C/(Pa^2)$.
      set E2                = -611.4

      # Mass fraction of clinopyroxene in the peridotite to be molten. Units:
      # non-dimensional.
      set Mass fraction cpx = 0.3

      # Exponent of the melting temperature in the melt fraction calculation.
      # Units: non-dimensional.
      set beta              = 1.5

      # Constant in the linear function that approximates the clinopyroxene
      # reaction coefficient. Units: non-dimensional.
      set r1                = 0.4

      # Prefactor of the linear pressure term in the linear function that
      # approximates the clinopyroxene reaction coefficient. Units: $1/Pa$.
      set r2                = 8e-11
    end

  end

end


subsection Termination criteria
  # Whether to checkpoint the simulation right before termination.
  set Checkpoint on termination = false

  # Terminate the simulation once the specified timestep has been reached.
  set End step                  = 100

  # A comma separated list of termination criteria that will determine when
  # the simulation should end. Whether explicitly stated or not, the ``end
  # time'' termination criterion will always be used.The following termination
  # criteria are available:
  # 
  # `end step': Terminate the simulation once the specified timestep has been
  # reached.
  # 
  # `end time': Terminate the simulation once the end time specified in the
  # input file has been reached. Unlike all other termination criteria, this
  # criterion is \textit{always} active, whether it has been explicitly
  # selected or not in the input file (this is done to preserve historical
  # behavior of \aspect{}, but it also likely does not inconvenience anyone
  # since it is what would be selected in most cases anyway).
  # 
  # `steady state velocity': A criterion that terminates the simulation when
  # the RMS of the velocity field stays within a certain range for a specified
  # period of time.
  # 
  # `user request': Terminate the simulation gracefully when a file with a
  # specified name appears in the output directory. This allows the user to
  # gracefully exit the simulation at any time by simply creating such a file
  # using, for example, \texttt{touch output/terminate}. The file's location
  # is chosen to be in the output directory, rather than in a generic location
  # such as the Aspect directory, so that one can run multiple simulations at
  # the same time (which presumably write to different output directories) and
  # can selectively terminate a particular one.
  set Termination criteria      = end time


  subsection Steady state velocity
    # The maximum relative deviation of the RMS in recent simulation time for
    # the system to be considered in steady state. If the actual deviation is
    # smaller than this number, then the simulation will be terminated.
    set Maximum relative deviation = 0.05

    # The minimum length of simulation time that the system should be in
    # steady state before termination.Units: years if the 'Use years in output
    # instead of seconds' parameter is set; seconds otherwise.
    set Time in steady state       = 1e7
  end

  subsection User request
    # The name of a file that, if it exists in the output directory (whose
    # name is also specified in the input file) will lead to termination of
    # the simulation. The file's location is chosen to be in the output
    # directory, rather than in a generic location such as the Aspect
    # directory, so that one can run multiple simulations at the same time
    # (which presumably write to different output directories) and can
    # selectively terminate a particular one.
    set File name = terminate-aspect
  end

end


